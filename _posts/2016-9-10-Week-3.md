---
layout: post
title: Week 3 (9/4 - 9/10)
---

**This past week**, I worked on finishing up the Collatz project and attended Engineering Expo. As Professor Downing said, we should "move heaven and earth to not be here this coming summer and to get an internship instead". From my experience, internships have always been rewarding experiences. 

**What is in my way?** Not much is blocking me in OOP at the moment. I need to remember to stay up-to-date on the readings.

**Next week**, the second assignment will be released. I'll try to find a partner and apply the pair programming readings from last week to this assignment.

## Class Thoughts
This week was pretty interesting, to say the least. We spent Wednesday covering pre- and post-increment.This was accompanied by a healthy discussion of pass-by-value and pass-by-reference semantics. Downing reassured us that we didn't fully understand the topic, which was definitely proven correct when we got a collective ~33% on the quiz Friday. 

Pointers are often considered one of the hardest subjects for aspiring programmers to grasp. A single level of indirection takes a while to get used to. Then you get something like: 

```c
int *(*(*ptr)(int))[4]; 
```

which just looks completely incomprehensible. This is a pointer to a function with an int parameter that returns a pointer to an array of 4 pointers to ints, for anyone curious. 

The notion of references also appeared stump the class as a whole to some degree, especially when combined with raw pointers. Downing's explanation that references are essentially fixed name aliases for locations in memory was spot-on and a good way to explain the topic. He also drew diagrams on the board that helped to cement the concept.

## Move Semantics 
The natural extension to our discussion of references is *move semantics*, which are explained very well in [this article](http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html). We've discussed rvalues and lvalues in class, so we're familiar with how lvalues refer to memory locations while rvalues... don't. 

People have probably encountered copy constructors in languages like Java when a deep clone needs to be done on an object. They function much the same in C++, allowing a programmer to instantiate a new class instance and copy the values one-by-one from the object to clone.

The problem is that the copy constructor has to allocate new memory for any nested instance members and copy their values, which can be quite slow. The copy constructor must be called in cases where nested objects are passed by value, for example as a function return value. 

Simply passing the outer pointer clearly wouldn't create a 'correct' object. New in C++11, it was noticed that  

## Collatz Musings

### Tip of the Week



